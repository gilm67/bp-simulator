        st.session_state.prospects_list[idx] = {
            "Name": st.session_state.p_name.strip(),
            "Source": st.session_state.p_source,
            "Wealth (M)": float(st.session_state.p_wealth),
            "Best NNM (M)": float(st.session_state.p_best),
            "Worst NNM (M)": float(st.session_state.p_worst),
        }
        st.session_state.edit_index = -1
        _reset_form()
        st.success("Prospect updated.")

if cancel_clicked:
    st.session_state.edit_index = -1
    _reset_form()
    st.info("Edit cancelled.")

df_pros = pd.DataFrame(
    st.session_state.prospects_list,
    columns=["Name","Source","Wealth (M)","Best NNM (M)","Worst NNM (M)"]
)

if not df_pros.empty:
    for i, row in df_pros.iterrows():
        colA, colB, colC, colD, colE, colF = st.columns([2,2,2,2,1,1])
        colA.write(row["Name"])
        colB.write(row["Source"])
        colC.write(f"{row['Wealth (M)']:,.1f}")
        colD.write(f"{row['Best NNM (M)']:,.1f} / {row['Worst NNM (M)']:,.1f}")

        if colE.button("‚úèÔ∏è Edit", key=f"edit_{i}"):
            st.session_state.edit_index = i
            st.session_state.p_name = row["Name"]
            st.session_state.p_source = row["Source"] if row["Source"] in ["Self Acquired","Inherited","Finder"] else "Self Acquired"
            st.session_state.p_wealth = float(row["Wealth (M)"] or 0.0)
            st.session_state.p_best = float(row["Best NNM (M)"] or 0.0)
            st.session_state.p_worst = float(row["Worst NNM (M)"] or 0.0)
            st.rerun()

        if colF.button("üóë Delete", key=f"del_{i}"):
            del st.session_state.prospects_list[i]
            st.rerun()

cols = ["Name", "Source", "Wealth (M)", "Best NNM (M)", "Worst NNM (M)"]
if df_pros.empty:
    df_pros = pd.DataFrame(columns=cols).astype({
        "Name": "string","Source": "string",
        "Wealth (M)": "float64","Best NNM (M)": "float64","Worst NNM (M)": "float64",
    })
else:
    df_pros = df_pros.astype({
        "Name": "string","Source": "string",
        "Wealth (M)": "float64","Best NNM (M)": "float64","Worst NNM (M)": "float64",
    }, errors="ignore")

total_row = pd.DataFrame(
    [{
        "Name": "TOTAL","Source": "",
        "Wealth (M)": float(df_pros["Wealth (M)"].sum()) if not df_pros.empty else 0.0,
        "Best NNM (M)": float(df_pros["Best NNM (M)"].sum()) if not df_pros.empty else 0.0,
        "Worst NNM (M)": float(df_pros["Worst NNM (M)"].sum()) if not df_pros.empty else 0.0,
    }],
    columns=cols
).astype(df_pros.dtypes.to_dict(), errors="ignore")

frames = [df for df in (df_pros, total_row) if not df.empty]
df_display = pd.concat(frames, ignore_index=True) if frames else total_row.copy()

highlighter = _make_highlighter(len(df_display))
st.dataframe(df_display.style.apply(highlighter, axis=1), use_container_width=True)
st.markdown('</div>', unsafe_allow_html=True)

best_sum = float(df_pros["Best NNM (M)"].sum()) if not df_pros.empty else 0.0
st.caption(f"Œî Best NNM vs NNM Y1: {best_sum - float(nnm_y1 or 0.0):+.1f} M")

# ---------- SECTION 4 ----------
st.markdown('<div class="ep-card">', unsafe_allow_html=True)
st.markdown('<span class="ep-chip">4Ô∏è‚É£ Revenue, Costs & Net Margin Analysis</span>', unsafe_allow_html=True)
roa_cols = st.columns(3)
roa_y1 = roa_cols[0].number_input("ROA % Year 1", min_value=0.0, value=1.0, step=0.1)
roa_y2 = roa_cols[1].number_input("ROA % Year 2", min_value=0.0, value=1.0, step=0.1)
roa_y3 = roa_cols[2].number_input("ROA % Year 3", min_value=0.0, value=1.0, step=0.1)

rev1 = nnm_y1 * roa_y1 / 100 * 1_000_000
rev2 = nnm_y2 * roa_y2 / 100 * 1_000_000
rev3 = nnm_y3 * roa_y3 / 100 * 1_000_000

fixed_cost = base_salary * 1.25

nm1 = rev1 - fixed_cost
nm2 = rev2 - fixed_cost
nm3 = rev3 - fixed_cost

gross_total = rev1 + rev2 + rev3
total_costs = fixed_cost * 3
nm_total = nm1 + nm2 + nm3

df_rev = pd.DataFrame(
    {
        "Year": ["Year 1", "Year 2", "Year 3", "Total"],
        "Gross Revenue": [rev1, rev2, rev3, rev1+rev2+rev3],
        "Fixed Cost": [fixed_cost, fixed_cost, fixed_cost, total_costs],
        "Net Margin": [nm1, nm2, nm3, nm_total],
    }
)
col_table, col_chart = st.columns(2)
with col_table:
    st.table(
        df_rev.set_index("Year").style.format(
            {"Gross Revenue": "{:,.0f}", "Fixed Cost": "{:,.0f}", "Net Margin": "{:,.0f}"}
        )
    )
with col_chart:
    st.bar_chart(df_rev.set_index("Year")[["Gross Revenue", "Net Margin"]])
st.markdown('</div>', unsafe_allow_html=True)

# === Sidebar Snapshot (live) ===
with st.sidebar:
    st.markdown("#### Snapshot")
    st.caption("Auto-updates as you fill the form")
    st.metric("Total 3-Year Gross (CHF)", f"{(rev1+rev2+rev3):,.0f}")
    st.metric("Total 3-Year Net (CHF)", f"{nm_total:,.0f}")
    st.metric("Avg ROA (%)", f"{((roa_y1+roa_y2+roa_y3)/3):.2f}")
    _verdict_preview = "‚Äî"
    if "üü¢" in st.session_state.get("_verdict",""):
        _verdict_preview = "üü¢ Strong"
    elif "üü°" in st.session_state.get("_verdict",""):
        _verdict_preview = "üü° Medium"
    elif "üî¥" in st.session_state.get("_verdict",""):
        _verdict_preview = "üî¥ Weak"
    st.metric("Fit Indicator", _verdict_preview)
    st.divider()
    st.caption("Powered by Executive Partners ¬∑ Secure submission")

# ---------- SECTION 5 (Recruiter-only UI, always compute) ----------
st.markdown('<div class="ep-card">', unsafe_allow_html=True)
st.markdown('<span class="ep-chip">5Ô∏è‚É£ AI Candidate Analysis (Recruiter)</span>', unsafe_allow_html=True)

if recruiter_mode:
    seg_col1, seg_col2 = st.columns(2)
    with seg_col1:
        target_segment = st.selectbox("Target Segment (for thresholds)", ["HNWI", "UHNWI"], index=0)
    with seg_col2:
        tolerance_pct = st.slider("NNM vs Prospects tolerance (%)", 0, 50, 10, 1)
else:
    target_segment = "HNWI"
    tolerance_pct = 10

total_nnm_3y = float(nnm_y1 + nnm_y2 + nnm_y3)
avg_roa = float((roa_y1 + roa_y2 + roa_y3) / 3)

if current_market == "CH Onshore":
    aum_min = 200.0
else:
    aum_min = 200.0 if target_segment == "HNWI" else 300.0

score = 0
reasons_pos, reasons_neg, flags = [], [], []

if years_experience >= 7:
    score += 2; reasons_pos.append("Experience ‚â•7 years in market")
elif years_experience >= 6:
    score += 1; reasons_pos.append("Experience 6 years")
else:
    reasons_neg.append("Experience <6 years")

if current_assets >= aum_min:
    if current_market == "CH Onshore" and current_assets >= 250:
        score += 2; reasons_pos.append("AUM meets CH 250M target")
    else:
        score += 2; reasons_pos.append(f"AUM ‚â• {aum_min}M")
else:
    reasons_neg.append(f"AUM shortfall: {aum_min - current_assets:.0f}M")

if base_salary > 200_000 and last_bonus > 100_000:
    score += 2; reasons_pos.append("Comp indicates hunter profile")
elif base_salary <= 150_000 and last_bonus <= 50_000:
    score -= 1; reasons_neg.append("Low comp indicates inherited/low portability")
else:
    flags.append("Comp neutral ‚Äì clarify origin of book")

if avg_roa >= 1.0:
    score += 2; reasons_pos.append(f"Avg ROA {avg_roa:.2f}% (excellent)")
elif avg_roa >= 0.8:
    score += 1; reasons_pos.append(f"Avg ROA {avg_roa:.2f}% (acceptable)")
else:
    reasons_neg.append(f"Avg ROA {avg_roa:.2f}% is low")

if current_number_clients == 0:
    flags.append("Clients not provided")
elif current_number_clients > 80:
    reasons_neg.append(f"High client count ({current_number_clients}) ‚Äì likely lower segment")
else:
    score += 1; reasons_pos.append("Client load appropriate (‚â§80)")

df_pros_check = pd.DataFrame(
    st.session_state.prospects_list,
    columns=["Name","Source","Wealth (M)","Best NNM (M)","Worst NNM (M)"]
)
nnm_y1_val = float(nnm_y1) if nnm_y1 is not None else 0.0
best_sum = float(df_pros_check["Best NNM (M)"].sum()) if not df_pros_check.empty else 0.0
tol = max(0.0, tolerance_pct) / 100.0
if nnm_y1_val == 0.0 and best_sum == 0.0:
    flags.append("Prospects & NNM Y1 both zero")
elif abs(best_sum - nnm_y1_val) <= tol * max(nnm_y1_val, 1e-9):
    score += 1; reasons_pos.append(
        f"Prospects Best NNM {best_sum:.1f}M ‚âà NNM Y1 {nnm_y1_val:.1f}M"
    )
else:
    reasons_neg.append(
        f"Prospects {best_sum:.1f}M vs NNM Y1 {nnm_y1_val:.1f}M (> {int(tolerance_pct)}% dev)"
    )

if score >= 7:
    verdict = "üü¢ Strong Candidate"
elif score >= 4:
    verdict = "üü° Medium Potential"
else:
    verdict = "üî¥ Weak Candidate"

st.session_state["_score"] = score
st.session_state["_verdict"] = verdict

if recruiter_mode:
    st.subheader(f"Traffic Light: {verdict} (score {score}/10)")
    colA, colB, colC = st.columns(3)
    with colA:
        st.markdown("**Positives**")
        if reasons_pos:
            for r in reasons_pos:
                st.markdown(f"- ‚úÖ {r}")
        else:
            st.markdown("- ‚Äî")
    with colB:
        st.markdown("**Risks / Gaps**")
        if reasons_neg:
            for r in reasons_neg:
                st.markdown(f"- ‚ùå {r}")
        else:
            st.markdown("- ‚Äî")
    with colC:
        st.markdown("**Flags / To Clarify**")
        if flags:
            for r in flags:
                st.markdown(f"- ‚ö†Ô∏è {r}")
        else:
            st.markdown("- ‚Äî")

    m1, m2, m3, m4 = st.columns(4)
    with m1:
        st.metric("AUM (M)", f"{current_assets:,.0f}")
    with m2:
        st.metric("Avg ROA %", f"{avg_roa:.2f}")
    with m3:
        st.metric("3Y NNM (M)", f"{total_nnm_3y:.1f}")
    with m4:
        st.metric("Clients", f"{int(current_number_clients)}")
else:
    st.caption("Recruiter analysis is hidden. Use the PIN to view.")
st.markdown('</div>', unsafe_allow_html=True)

# ---------- SECTION 6 ----------
st.markdown('<div class="ep-card">', unsafe_allow_html=True)
st.markdown('<span class="ep-chip">6Ô∏è‚É£ Summary, PDF & Save</span>', unsafe_allow_html=True)
st.caption("Your PDF includes Sections 1‚Äì4 with **Executive Partners** watermark.")

score = st.session_state.get("_score", 0)
verdict = st.session_state.get("_verdict", "")

def _email_valid(e: str) -> bool:
    return isinstance(e, str) and "@" in e and "." in (e.split("@")[-1] if "@" in e else "")

def _build_data_dict():
    total_rev_3y = ((nnm_y1 * roa_y1) + (nnm_y2 * roa_y2) + (nnm_y3 * roa_y3)) / 100 * 1_000_000
    profit_margin_pct = (
        (((total_rev_3y - (base_salary * 1.25 * 3)) / total_rev_3y) * 100.0) if total_rev_3y > 0 else 0.0
    )
    total_profit_3y = (
        (nnm_y1 * roa_y1 / 100 * 1_000_000) +
        (nnm_y2 * roa_y2 / 100 * 1_000_000) +
        (nnm_y3 * roa_y3 / 100 * 1_000_000)
    ) - (base_salary * 1.25 * 3)

    return {
        "Timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        "Candidate Name": candidate_name,
        "Candidate Email": candidate_email,
        "Current Role": current_role,
        "Candidate Location": candidate_location,
        "Current Employer": current_employer,
        "Current Market": current_market,
        "Currency": currency,
        "Base Salary": base_salary,
        "Last Bonus": last_bonus,
        "Current Number of Clients": current_number_clients,
        "Current AUM (M CHF)": current_assets,
        "NNM Year 1 (M CHF)": nnm_y1,
        "NNM Year 2 (M CHF)": nnm_y2,
        "NNM Year 3 (M CHF)": nnm_y3,
        "Revenue Year 1 (CHF)": nnm_y1 * roa_y1 / 100 * 1_000_000,
        "Revenue Year 2 (CHF)": nnm_y2 * roa_y2 / 100 * 1_000_000,
        "Revenue Year 3 (CHF)": nnm_y3 * roa_y3 / 100 * 1_000_000,
        "Total Revenue 3Y (CHF)": total_rev_3y,
        "Profit Margin (%)": profit_margin_pct,
        "Total Profit 3Y (CHF)": total_profit_3y,
        "Score": score,
        "AI Evaluation Notes": verdict
    }

def _inputs_ok_for_save():
    missing = []
    if not _email_valid(candidate_email):
        missing.append("Candidate Email (valid)")
    if candidate_location == "‚Äî Select ‚Äî":
        missing.append("Candidate Location")
    return (len(missing) == 0, ", ".join(missing))

def _save_to_sheet_if_possible(data_dict, reason=""):
    if not worksheet:
        st.warning("‚ö†Ô∏è Google Sheet connection not available.")
        return False
    # de-dupe by signature
    sig = _make_signature(data_dict)
    if st.session_state.get("_last_sig") == sig:
        st.info("Already saved. No duplicate entry created.")
        return False
    try:
        append_in_header_order(worksheet, data_dict)
        st.session_state["_last_sig"] = sig
        if reason:
            st.success(f"‚úÖ Saved to Google Sheet ({reason}).")
        else:
            st.success("‚úÖ Saved to Google Sheet.")
        return True
    except Exception as e:
        st.error(f"Error saving to Google Sheet: {e}")
        return False

# Build data + PDF once
candidate_dict = _build_data_dict()
pdf_buf = build_pdf(
    candidate=candidate_dict,
    prospects_df=df_display,  # includes TOTAL row
    revenue_df=pd.DataFrame({
        "Year": ["Year 1","Year 2","Year 3","Total"],
        "Gross Revenue": [rev1, rev2, rev3, rev1+rev2+rev3],
        "Fixed Cost": [fixed_cost, fixed_cost, fixed_cost, fixed_cost*3],
        "Net Margin": [nm1, nm2, nm3, nm1+nm2+nm3],
    })
)

# Actions row
left, right = st.columns([0.68, 0.32])
with left:
    download_clicked = st.download_button(
        label="üìÑ Download your Business Plan projection (PDF)",
        file_name=f"BP_{candidate_name or 'candidate'}_{datetime.now().strftime('%Y%m%d_%H%M')}.pdf",
        mime="application/pdf",
        data=pdf_buf.getvalue(),
        use_container_width=True
    )
with right:
    manual_clicked = st.button("üíæ Save to Google Sheet (manual)", use_container_width=True)

# Validation + actions
ok_to_save, missing_msg = _inputs_ok_for_save()

# Auto-save: always
if AUTO_SAVE_MODE == "always" and ok_to_save:
    if not st.session_state.get("_autosaved_hash"):
        st.session_state["_autosaved_hash"] = ""
    current_hash = json.dumps({
        "email": candidate_email,
        "nnm": [nnm_y1, nnm_y2, nnm_y3],
        "aum": current_assets,
        "base": base_salary,
    }, sort_keys=True)
    if current_hash != st.session_state["_autosaved_hash"]:
        if _save_to_sheet_if_possible(candidate_dict, reason="AUTO (always)"):
            st.session_state["_autosaved_hash"] = current_hash

# Auto-save: when PDF generated
if AUTO_SAVE_MODE == "on_pdf" and download_clicked:
    if ok_to_save:
        _save_to_sheet_if_possible(candidate_dict, reason="PDF generated")
    else:
        st.warning(f"Not saved ‚Äî missing: {missing_msg}")

# Manual save
if manual_clicked:
    if ok_to_save:
        _save_to_sheet_if_possible(candidate_dict, reason="manual")
    else:
        st.error("Please complete the required fields: " + missing_msg)

st.markdown('</div>', unsafe_allow_html=True)
